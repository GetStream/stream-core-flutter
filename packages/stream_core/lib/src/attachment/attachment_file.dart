import 'dart:typed_data';

import 'package:cross_file/cross_file.dart';
import 'package:dio/dio.dart' show MultipartFile;
import 'package:http_parser/http_parser.dart' show MediaType;
import 'package:mime/mime.dart';

import '../platform.dart';
import '../utils.dart';

/// Cross-platform file wrapper for Stream attachments.
///
/// Provides a unified interface for working with files across different platforms
/// (mobile, desktop, web) by wrapping the [XFile] class. Supports both file path-based
/// and byte data-based file creation with automatic MIME type detection.
///
/// The class handles platform-specific limitations, such as web platform restrictions
/// on file path access, and provides convenient methods for file operations and
/// HTTP upload conversion.
///
/// Example usage:
/// ```dart
/// // Create from file path (not supported on web)
/// final file = AttachmentFile('/path/to/image.png');
///
/// // Create from byte data (works on all platforms)
/// final file = AttachmentFile.fromData(bytes, name: 'image.png');
///
/// // Convert to multipart file for upload
/// final multipart = await file.toMultipartFile();
/// ```
class AttachmentFile {
  /// Creates an [AttachmentFile] from a file path.
  ///
  /// This constructor is not supported on web platforms due to security restrictions.
  /// Use [AttachmentFile.fromData] instead for web applications.
  ///
  /// The [path] parameter should be a valid file system path to an existing file.
  /// The [mimeType] can be provided to override automatic MIME type detection.
  /// The [lastModified] parameter allows setting a custom last modified timestamp.
  ///
  /// Throws an [UnsupportedError] when called on web platforms.
  factory AttachmentFile(
    String path, {
    String? mimeType,
    DateTime? lastModified,
  }) {
    if (CurrentPlatform.isWeb) {
      throw UnsupportedError(
        'AttachmentFile() is not supported on web. Use AttachmentFile.fromData instead.',
      );
    }

    final file = XFile(
      path,
      mimeType: mimeType,
      lastModified: lastModified,
    );

    return AttachmentFile.fromXFile(file);
  }

  /// Creates an [AttachmentFile] from byte data.
  ///
  /// This constructor works on all platforms, including web, making it the preferred
  /// method for cross-platform file handling.
  ///
  /// The [bytes] parameter contains the file's binary data.
  /// The [name] parameter should include a file extension (e.g., 'image.png').
  /// The [mimeType] can be provided to override automatic MIME type detection.
  ///
  /// Throws an [ArgumentError] if [name] is provided but doesn't contain a file extension.
  factory AttachmentFile.fromData(
    Uint8List bytes, {
    String? name,
    String? mimeType,
  }) {
    if (name != null && name.isNotEmpty && !name.contains('.')) {
      throw ArgumentError.value(
        name,
        'name',
        'Invalid file name, must contain an extension (e.g. "image.png").',
      );
    }

    final file = XFile.fromData(
      bytes,
      name: name,
      mimeType: mimeType,
    );

    return AttachmentFile.fromXFile(file);
  }

  /// Creates an [AttachmentFile] from an [XFile].
  ///
  /// This constructor is useful for integrating with packages like image_picker
  /// and file_picker that return [XFile] instances.
  const AttachmentFile.fromXFile(this._file);

  final XFile _file;

  /// The file path.
  ///
  /// Returns the path to the file. For files created with [fromData], this will
  /// be a temporary path generated by the underlying [XFile] implementation.
  String get path => _file.path;

  /// The file name including extension.
  ///
  /// Returns the name of the file, including the extension if available.
  /// For files created with [fromData], this will be the name provided during
  /// construction or a generated name if none was provided.
  String get name => _file.name;

  /// The file size in bytes.
  ///
  /// Returns a [Future] that completes with the size of the file in bytes.
  /// This operation may involve reading the file, so it's asynchronous.
  Future<int> get size => _file.length();

  /// Reads the file as a list of bytes.
  ///
  /// Returns a [Future] that completes with the file's content as a [Uint8List].
  /// This is the primary method for accessing file content.
  Future<Uint8List> readAsBytes() => _file.readAsBytes();

  /// The file extension without the leading dot.
  ///
  /// Returns the file extension (e.g., 'png', 'jpg', 'pdf') without the leading dot.
  /// Returns null if the file name doesn't contain an extension.
  String? get extension => name.split('.').lastOrNull;

  /// The MIME type of the file.
  ///
  /// Returns the MIME type (e.g., 'image/png', 'application/pdf') of the file.
  /// First attempts to use the MIME type provided during construction, then
  /// falls back to automatic detection based on the file extension.
  String? get mimeType {
    if (_file.mimeType case final mimeType?) return mimeType;
    return name.let(lookupMimeType);
  }

  /// The parsed media type.
  ///
  /// Returns a [MediaType] object parsed from the [mimeType], or null if
  /// the MIME type is not available or cannot be parsed.
  MediaType? get mediaType => mimeType?.let(MediaType.parse);

  /// Saves the file to the specified [path].
  ///
  /// Writes the file content to the file system at the given [path].
  /// Returns a [Future] that completes when the save operation finishes.
  Future<void> saveTo(String path) => _file.saveTo(path);
}

/// Extension methods for converting [AttachmentFile] to [MultipartFile].
///
/// This extension provides convenient methods for converting [AttachmentFile] instances
/// to [MultipartFile] objects, which are commonly used for HTTP file uploads with
/// Dio and other HTTP clients.
extension AttachmentFileMultipartExtension on AttachmentFile {
  /// Converts this [AttachmentFile] to a [MultipartFile].
  ///
  /// This method attempts to create a [MultipartFile] using the file path first,
  /// which is more efficient for large files. If that fails (e.g., on web platforms
  /// or when the file path is not accessible), it falls back to reading the file
  /// as bytes and creating the multipart file from the byte data.
  ///
  /// The resulting [MultipartFile] will include the file name and content type
  /// information from this [AttachmentFile].
  ///
  /// Returns a [Future] that completes with a [MultipartFile] ready for HTTP upload.
  Future<MultipartFile> toMultipartFile() async {
    // Try path-based creation first (more efficient for large files)
    final result = runSafelySync(
      () => MultipartFile.fromFile(
        path,
        filename: name,
        contentType: mediaType,
      ),
    );

    final multipartFile = result.getOrNull();
    if (multipartFile != null) return multipartFile;

    // Fallback to byte-based creation (web platforms, inaccessible paths)
    final bytes = await readAsBytes();
    return MultipartFile.fromBytes(
      bytes,
      filename: name,
      contentType: mediaType,
    );
  }
}
